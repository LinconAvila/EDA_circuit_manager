<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circuit Manager</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>

<body>
  <header>
    <h1>Circuit Manager</h1>
    <p>Visualize and manage your circuit layouts</p>
  </header>

  <div class="form-container">
    <div class="form-card">
      <h2>Load Circuit File</h2>
      <form method="POST" action="/load" enctype="multipart/form-data" class="form-inline">
        <input type="file" name="file" required>
        <button class="btn btn-dark" type="submit">Load File</button>
      </form>
    </div>

    <div class="form-card">
      <h2>Search Cell</h2>
      <form method="POST" action="/search" class="form-inline">
        <input type="text" name="id" placeholder="Enter Cell ID" required>
        <button class="btn btn-primary" type="submit">Search Cell</button>
      </form>
    </div>

    <div class="form-card">
      <h2>Insert Cell</h2>
      <form method="POST" action="/insert" class="form-inline">
        <input type="text" name="id" placeholder="Cell ID" required>
        <input type="text" name="width" placeholder="Width" required>
        <input type="text" name="height" placeholder="Height" required>
        <button class="btn btn-success" type="submit">Insert Cell</button>
      </form>
    </div>

    <div class="form-card">
      <h2>Remove Cell</h2>
      <form method="POST" action="/remove" class="form-inline">
        <input type="text" name="id" placeholder="Cell ID to remove" required>
        <button class="btn btn-danger" type="submit">Remove Cell</button>
      </form>
    </div>
  </div>

  <div class="flash-messages">
    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    <ul>
        {% for category, msg in messages %}
        <li class="{{ category }}">{{ msg }}</li>
        {% endfor %}
    </ul>
    {% endif %}
    {% endwith %}
  </div>

  <div class="circuit-container">
    <div class="circuit">
      <canvas id="canvas" width="1000" height="600"></canvas>
    </div>
  </div>

  <div class="download-container">
    <form method="GET" action="/download" class="form-inline">
      <button class="btn btn-info" type="submit">Download Modified Circuit</button>
    </form>
  </div>

  <script>
    let circuitData = [];
    let hoveredCell = null;
    const rowHeight = 30;
    const cellHeight = 25;
    let scale = 0.5;
    let offsetX = 0;
    let isDragging = false;
    let lastX = 0;

    async function drawCircuit() {
        const response = await fetch('/circuit_json');
        circuitData = await response.json();
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const maxX = Math.max(...circuitData.map(cell => cell.x + cell.width));
        if (maxX * scale > canvas.width) {
            scale = Math.min(0.5, canvas.width / (maxX + 100));
        }

        for (let i = 0; i < 145; i++) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.moveTo(-offsetX, i * rowHeight + cellHeight);
            ctx.lineTo(canvas.width - offsetX, i * rowHeight + cellHeight);
            ctx.stroke();
            
            ctx.fillStyle = '#999';
            ctx.font = '10px Inter';
            ctx.fillText(i.toString(), 5 - offsetX, i * rowHeight + cellHeight - 5);
        }

        for (const cell of circuitData) {
            const visualX = cell.x * scale - offsetX;
            const visualY = cell.y * rowHeight;
            const visualWidth = cell.width * scale;
            
            if (hoveredCell && hoveredCell.id === cell.id) {
                ctx.fillStyle = 'rgba(247, 37, 133, 0.8)';
                ctx.strokeStyle = '#f72585';
            } else {
                ctx.fillStyle = 'rgba(67, 97, 238, 0.7)';
                ctx.strokeStyle = '#4361ee';
            }
            
            if (visualX + visualWidth > 0 && visualX < canvas.width) {
                ctx.fillRect(visualX, visualY, visualWidth, cellHeight);
                ctx.strokeRect(visualX, visualY, visualWidth, cellHeight);
                
                ctx.fillStyle = '#fff';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(cell.id, visualX + visualWidth / 2, visualY + cellHeight / 2 + 4);
            }
        }

        if (hoveredCell) {
            drawTooltip(ctx, hoveredCell);
        }
    }

    function drawTooltip(ctx, cell) {
        const visualX = cell.x * scale - offsetX;
        const visualY = cell.y * rowHeight;
        const visualWidth = cell.width * scale;
        
        const tooltipX = visualX + visualWidth / 2;
        const tooltipY = visualY - 10;
        
        const text = [
            `ID: ${cell.id}`,
            `Row: ${cell.y}`,
            `X: ${cell.x.toFixed(2)}`,
            `Width: ${cell.width.toFixed(2)}`,
            `Height: ${cell.height.toFixed(2)}`
        ];
        
        ctx.font = 'bold 12px Inter';
        const textWidth = Math.max(...text.map(line => ctx.measureText(line).width));
        const textHeight = text.length * 18;
        
        const canvas = ctx.canvas;
        const padding = 8;
        const tooltipWidth = textWidth + padding * 2;
        const tooltipHeight = textHeight + padding * 2;
        
        const finalX = Math.max(padding, Math.min(tooltipX - tooltipWidth/2, canvas.width - tooltipWidth - padding));
        const finalY = Math.max(padding, tooltipY - tooltipHeight - padding);
        
        ctx.fillStyle = 'rgba(30, 30, 30, 0.95)';
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        
        const radius = 6;
        ctx.beginPath();
        ctx.moveTo(finalX + radius, finalY);
        ctx.lineTo(finalX + tooltipWidth - radius, finalY);
        ctx.quadraticCurveTo(finalX + tooltipWidth, finalY, finalX + tooltipWidth, finalY + radius);
        ctx.lineTo(finalX + tooltipWidth, finalY + tooltipHeight - radius);
        ctx.quadraticCurveTo(finalX + tooltipWidth, finalY + tooltipHeight, finalX + tooltipWidth - radius, finalY + tooltipHeight);
        ctx.lineTo(finalX + radius, finalY + tooltipHeight);
        ctx.quadraticCurveTo(finalX, finalY + tooltipHeight, finalX, finalY + tooltipHeight - radius);
        ctx.lineTo(finalX, finalY + radius);
        ctx.quadraticCurveTo(finalX, finalY, finalX + radius, finalY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.font = '12px Inter';
        text.forEach((line, i) => {
            ctx.fillText(line, finalX + padding, finalY + padding + i * 18);
        });
    }

    document.getElementById('canvas').addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.clientX - lastX;
        lastX = e.clientX;
        offsetX -= deltaX;
        
        const canvas = document.getElementById('canvas');
        const maxX = Math.max(0, Math.max(...circuitData.map(cell => cell.x * scale)) - canvas.width / 2);
        offsetX = Math.max(0, Math.min(offsetX, maxX));
        
        drawCircuit();
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
    });

    function centerCell(cellId) {
        const cell = circuitData.find(c => c.id === cellId);
        if (cell) {
            const canvas = document.getElementById('canvas');
            offsetX = Math.max(0, cell.x * scale - canvas.width / 2 + (cell.width * scale / 2));
            drawCircuit();
        }
    }

    document.querySelector('form[action="/search"]').addEventListener('submit', function(e) {
        e.preventDefault();
        const formData = new FormData(this);
        fetch('/search', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            fetch('/')
            .then(response => response.text())
            .then(html => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const flashMessages = doc.querySelector('.flash-messages');
                if (flashMessages) {
                    document.querySelector('.flash-messages').innerHTML = flashMessages.innerHTML;
                }
                if (data.status === "success" && data.cell) {
                    centerCell(data.cell.id);
                    drawCircuit();
                }
            });
        })
        .catch(error => {
            console.error('Error:', error);
            const flashContainer = document.querySelector('.flash-messages');
            flashContainer.innerHTML = `
                <ul>
                    <li class="error">An error occurred during search</li>
                </ul>
            `;
        });
    });

    document.getElementById('canvas').addEventListener('mousemove', (e) => {
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left + offsetX;
        const mouseY = e.clientY - rect.top;
        
        hoveredCell = null;
        for (const cell of circuitData) {
            const visualX = cell.x * scale;
            const visualY = cell.y * rowHeight;
            const visualWidth = cell.width * scale;
            
            if (mouseX >= visualX && mouseX <= visualX + visualWidth &&
                mouseY >= visualY && mouseY <= visualY + cellHeight) {
                hoveredCell = cell;
                break;
            }
        }
        
        drawCircuit();
    });

    document.getElementById('canvas').addEventListener('mouseleave', () => {
        hoveredCell = null;
        drawCircuit();
    });

    window.onload = drawCircuit;
    document.querySelectorAll('form button').forEach(btn => {
        if (btn.form.action !== '/search') {
            btn.addEventListener('click', () => setTimeout(drawCircuit, 300));
        }
    });
  </script>
</body>
</html>